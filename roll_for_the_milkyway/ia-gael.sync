/**
    --------------------------------------------------------
    IA pour Roll For The Milkyway - Projet MEIM11
    Auteur: Gaël ODDOS-MARCEL

    ## Explication de l'algorithme

    Mon IA utilise une stratégie dite "gloutonne". L'objectif est de 
    toujours prendre la décision qui semble la plus rentable en calculant un rapport bénéfice/coût.

    1. Stratégie de Choix de l'Objectif (Ciblage) :
    Plutôt que de viser un objectif au hasard, l'IA calcule un score de priorité pour chaque mission disponible. La formule utilisée est la suivante :
    $$Score = \frac{Points \times 100}{Distance + 1}$$
    La "distance" représente le nombre total de ressources qu'il manque pour accomplir cet objectif. Plus un objectif rapporte de points et plus il est proche d'être complété, plus son score est élevé. 

    2. Stratégie de Mouvement (Phase de déplacement) :
    Une fois l'objectif cible choisi, l'IA analyse chaque dé pour voir s'il peut aider à combler un manque. Pour chaque dé, elle regarde les faces en avant et en arrière pour trouver la ressource manquante la plus proche. 
    Elle applique ensuite le mouvement minimal (1 ou -1). Elle respecte la règle de sécurité : un seul mouvement maximum sur les dés partagés.

    3. Stratégie de Revendication (Validation) :
    L'IA vérifie ses ressources actuelles et les compare aux objectifs. Elle tente de valider en priorité les objectifs les plus difficiles (qui rapportent le plus de points) s'ils sont réalisables. 
    Si rien n'est faisable, elle passe son tour.

    ## Aide de l'IA
    J'ai utilisé une intelligence artificielle pour m'aider à concevoir la structure technique du projet et pour définir la logique de la fonction gloutonne, ce qui m'a permis de mieux visualiser comment prioriser les ressources manquantes par rapport aux points de victoire.
    --------------------------------------------------------
*/

/**
--------------------------------------------------------
VARIABLES GLOBALES
--------------------------------------------------------
 */

GLOBALS
    mon_id = 0               // Identifiant de mon exploratrice
    nombre_joueurs = 0       // Nombre total de joueurs
    tour_actuel = 0          // Index du tour (1 à 3)
    action_actuelle = 0      // Index de l'action (1 à 6)

    de_faces = 0             // Tableau contenant la composition de chaque dé
    de_faces_compte = 0      // Tableau contenant le nombre de faces par dé
    face_visible_de = 0      // Index de la face actuellement sur le dessus

    player_infos = 0         // Informations sur les scores et l'état des joueurs
    liste_objectifs = 0      // Liste des 9 objectifs du tour en cours
    objectifs_effectues = 0  // Registre des objectifs déjà validés (Set de booléens)
ENDGLOBALS

/**
--------------------------------------------------------
STRUCTURES DE DONNÉES
--------------------------------------------------------
 */

STRUCT objective
    id
    points
    pe
    h3
    am
    mn
ENDSTRUCT

STRUCT player_info
    score
    est_actif
ENDSTRUCT

STRUCT analyse_mouvement
    distance 
    direction 
ENDSTRUCT

/**
--------------------------------------------------------
Calcule la position d'une face après un mouvement.
Cette fonction gère la boucle infinie du dé :
si on dépasse la dernière face, on revient à la première, et inversement.
--------------------------------------------------------
 */
FUNCTION prochaine_face(de_index, index_face_de, move)
    nombres_faces = de_faces_compte[de_index]
    new_face_index = index_face_de + move
    
    WHILE (new_face_index < 0)
        new_face_index = new_face_index + nombres_faces 
    ENDWHILE
    
    WHILE (new_face_index >= nombres_faces)
        new_face_index = new_face_index - nombres_faces 
    ENDWHILE

    RETURN new_face_index
END

/**
--------------------------------------------------------
Récupère le type de ressource (0 à 3) situé sur la face visible d'un dé spécifique.
--------------------------------------------------------
 */
FUNCTION ressource_pour_de(de_index)
    face_index = face_visible_de[de_index]
    resource_de = de_faces[de_index][face_index]
    RETURN resource_de
END

/**
--------------------------------------------------------
Analyse le chemin le plus court pour qu'un dé affiche une ressource précise.
La fonction compare le nombre de clics nécessaires en allant vers l'avant ou vers l'arrière. 
Elle retourne la direction (-1, 0, ou 1) et la distance.
--------------------------------------------------------
 */
FUNCTION deplacement_de_ressource(de_index, resource_code)
    nombres_faces = de_faces_compte[de_index]
    index_face_de = face_visible_de[de_index]
    
    ressource_actuelle = ressource_pour_de(de_index)
    IF (ressource_actuelle == resource_code)
        analysis = MALLOC_STRUCT(analyse_mouvement)
        analysis->distance = 0
        analysis->direction = 0
        RETURN analysis
    ENDIF

    dist_forward = 10
    dist_backward = 10
    max_search = (nombres_faces / 2) + 1 
    
    i = 1
    WHILE(i < max_search)
        IF (dist_forward == 10)
            next_face_idx = prochaine_face(de_index, index_face_de, i)
            IF (de_faces[de_index][next_face_idx] == resource_code)
                dist_forward = i
            ENDIF
        ENDIF
        
        IF (dist_backward == 10)
            prev_face_idx = prochaine_face(de_index, index_face_de, 0 - i)
            IF (de_faces[de_index][prev_face_idx] == resource_code)
                dist_backward = i
            ENDIF
        ENDIF
        
        IF (dist_forward != 10 AND dist_backward != 10)
            i = max_search
        ENDIF
        i = i + 1
    ENDWHILE
    
    analysis = MALLOC_STRUCT(analyse_mouvement)
    IF (dist_forward <= dist_backward)
        analysis->distance = dist_forward
        analysis->direction = 1
    ELIF (dist_backward < 10)
        analysis->distance = dist_backward
        analysis->direction = -1
    ELSE
        analysis->distance = 10
        analysis->direction = 0
    ENDIF
    
    RETURN analysis
END

 /**
--------------------------------------------------------
Prépare l'environnement de jeu au lancement.
Cette fonction alloue la mémoire pour les joueurs, les objectifs et définit la composition fixe de chaque face des 8 dés du jeu.
--------------------------------------------------------
 */
FUNCTION initialisation()
    nombre_joueurs = READ()
    mon_id = READ()
    tour_actuel = 0

    player_infos = MALLOC(nombre_joueurs)
    FOR(i;0;nombre_joueurs)
        player_infos[i] = MALLOC_STRUCT(player_info)
        player_infos[i]->score = 0
        player_infos[i]->est_actif = TRUE
    ENDFOR

    liste_objectifs = MALLOC(9)
    FOR(i;0;9)
        liste_objectifs[i] = MALLOC_STRUCT(objective)
    ENDFOR

    face_visible_de = MALLOC(8, 0, 0, 0, 0, 0, 0, 0, 0)
    objectifs_effectues = MALLOC(31)
    FOR(i;0;31)
        objectifs_effectues[i] = FALSE
    ENDFOR

    de_faces_compte = MALLOC(8, 4, 4, 4, 4, 5, 6, 5, 6)
    de_faces = MALLOC(8)
    de_faces[0] = MALLOC(4, 0, 2, 3, 2)
    de_faces[1] = MALLOC(4, 0, 1, 3, 1)
    de_faces[2] = MALLOC(4, 0, 1, 3, 2)
    de_faces[3] = MALLOC(4, 1, 3, 2, 3)
    de_faces[4] = MALLOC(5, 0, 0, 1, 1, 0)
    de_faces[5] = MALLOC(6, 0, 1, 1, 2, 1, 1)
    de_faces[6] = MALLOC(5, 0, 1, 2, 2, 1)
    de_faces[7] = MALLOC(6, 0, 2, 1, 3, 2, 1)
END

 /**
--------------------------------------------------------
Libère proprement toute la mémoire allouée dynamiquement à la fin de la partie pour éviter les fuites de mémoire.
--------------------------------------------------------
 */
FUNCTION nettoyage()
    FOR(i;0;8)
        FREE(de_faces[i])
    ENDFOR
    FREE(de_faces)
    FREE(de_faces_compte)
    FREE(face_visible_de)

    FOR(i;0;nombre_joueurs)
        FREE(player_infos[i])
    ENDFOR
    FREE(player_infos)

    FOR(i;0;9)
        FREE(liste_objectifs[i])
    ENDFOR
    FREE(liste_objectifs)

    FREE(objectifs_effectues)
END
 
/**
--------------------------------------------------------
Reçoit les données de début de tour.
Met à jour les scores des joueurs et les caractéristiques des 9 nouveaux objectifs (ID et ressources nécessaires).
--------------------------------------------------------
 */
FUNCTION lecture_debut_tour()
    FOR(i;0;nombre_joueurs)
        player_id = READ()
        player_infos[player_id - 1]->est_actif = READ()
        player_infos[player_id - 1]->score = READ() 
    ENDFOR

    FOR(i;0;9)
        obj_ptr = liste_objectifs[i]
        obj_ptr->id = READ()
        
        IF (i < 3)
            obj_ptr->points = 100
        ELIF (i < 6)
            obj_ptr->points = 150
        ELSE
            obj_ptr->points = 200
        ENDIF
        
        obj_ptr->pe = READ()
        obj_ptr->h3 = READ()
        obj_ptr->am = READ()
        obj_ptr->mn = READ()
    ENDFOR
END

/**
--------------------------------------------------------
Met à jour la position des dés après les mouvements de tous les joueurs.
La fonction additionne les mouvements sur les dés partagés et applique le mouvement direct pour nos propres dés.
--------------------------------------------------------
 */
FUNCTION lecture_des_bouges()
    total_moves = MALLOC(8, 0, 0, 0, 0, 0, 0, 0, 0)

    FOR(i;0;nombre_joueurs)
        player_id = READ()
        FOR(j;0;8)
            move = READ()
            IF (j < 4)
                total_moves[j] = total_moves[j] + move
            ELIF (player_id == mon_id)
                total_moves[j] = move
            ENDIF
        ENDFOR
    ENDFOR

    FOR(i;0;8)
        current_face = face_visible_de[i]
        final_move = total_moves[i]
        IF (final_move != 0)
            face_visible_de[i] = prochaine_face(i, current_face, final_move)
        ENDIF
    ENDFOR
    FREE(total_moves)
END

/**
--------------------------------------------------------
Enregistre quels objectifs ont été complétés durant la phase actuelle.
Cela permet d'éviter de viser un objectif qui n'est plus disponible.
--------------------------------------------------------
 */
FUNCTION lecture_objectif_fini()
    FOR(i;0;nombre_joueurs)
        player_id = READ()
        claimed_oid = READ()
        IF (claimed_oid > 0)
            objectifs_effectues[claimed_oid] = TRUE
        ENDIF
    ENDFOR
END

/**
--------------------------------------------------------
Compte combien de ressources de chaque type sont visibles sur la table.
Retourne un tableau de 4 entiers [PE, H3, AM, MN].
--------------------------------------------------------
 */
FUNCTION calculate_current_resources()
    resource_counts = MALLOC(4, 0, 0, 0, 0)
    FOR(i;0;8)
        resource_code = ressource_pour_de(i)
        resource_counts[resource_code] = resource_counts[resource_code] + 1
    ENDFOR
    RETURN resource_counts
END

/**
--------------------------------------------------------
Vérifie si les ressources actuelles suffisent à payer un objectif donné.
--------------------------------------------------------
 */
FUNCTION check_objective_achievable(obj_ptr, counts_ptr)
    IF (counts_ptr[0] < obj_ptr->pe)
        RETURN FALSE
    ENDIF
    IF (counts_ptr[1] < obj_ptr->h3)
        RETURN FALSE
    ENDIF
    IF (counts_ptr[2] < obj_ptr->am)
        RETURN FALSE
    ENDIF
    IF (counts_ptr[3] < obj_ptr->mn)
        RETURN FALSE
    ENDIF
    RETURN TRUE
END

/**
--------------------------------------------------------
Analyse la liste des objectifs et sélectionne celui qui a le meilleur score (Rapport Points / Distance). 
Ne prend en compte que les objectifs non validés.
--------------------------------------------------------
 */
FUNCTION trouver_meilleur_obj()
    best_score = -1
    best_obj_ptr = NULL
    current_counts_ptr = calculate_current_resources()

    FOR(i;0;9)
        obj_ptr = liste_objectifs[i]
        IF (NOT objectifs_effectues[obj_ptr->id])
            pe_missing = obj_ptr->pe - current_counts_ptr[0]
            h3_missing = obj_ptr->h3 - current_counts_ptr[1]
            am_missing = obj_ptr->am - current_counts_ptr[2]
            mn_missing = obj_ptr->mn - current_counts_ptr[3]

            distance = 0
            IF (pe_missing > 0)
                distance = distance + pe_missing
            ENDIF
            IF (h3_missing > 0)
                distance = distance + h3_missing
            ENDIF
            IF (am_missing > 0)
                distance = distance + am_missing
            ENDIF
            IF (mn_missing > 0)
                distance = distance + mn_missing
            ENDIF
            
            score = (obj_ptr->points * 100) / (distance + 1)
            
            IF (score > best_score)
                best_score = score
                best_obj_ptr = obj_ptr
            ENDIF
        ENDIF
    ENDFOR
    
    FREE(current_counts_ptr)
    RETURN best_obj_ptr
END

/**
--------------------------------------------------------
Gère l'envoi des ordres de mouvement des dés.
L'IA cible l'objectif prioritaire, identifie les ressources manquantes, et demande aux dés de tourner vers la ressource utile la plus proche.
--------------------------------------------------------
 */
FUNCTION phase_deplacement_des()
    target_obj = trouver_meilleur_obj()
    current_counts_ptr = calculate_current_resources()
    
    pe_missing = target_obj->pe - current_counts_ptr[0]
    h3_missing = target_obj->h3 - current_counts_ptr[1]
    am_missing = target_obj->am - current_counts_ptr[2]
    mn_missing = target_obj->mn - current_counts_ptr[3]
    FREE(current_counts_ptr)
    
    deja_bouge = FALSE
    FOR (i;0;8)
        min_dist = 999
        best_move = 0
        
        // Test successif pour chaque ressource dont on a encore besoin
        IF (pe_missing > 0)
            analysis = deplacement_de_ressource(i, 0)
            IF (analysis->distance < min_dist)
                min_dist = analysis->distance
                best_move = analysis->direction
            ENDIF
            FREE(analysis)
        ENDIF
        
        IF (h3_missing > 0)
            analysis = deplacement_de_ressource(i, 1)
            IF (analysis->distance < min_dist)
                min_dist = analysis->distance
                best_move = analysis->direction
            ENDIF
            FREE(analysis)
        ENDIF
        
        IF (am_missing > 0)
            analysis = deplacement_de_ressource(i, 2)
            IF (analysis->distance < min_dist)
                min_dist = analysis->distance
                best_move = analysis->direction
            ENDIF
            FREE(analysis)
        ENDIF
        
        IF (mn_missing > 0)
            analysis = deplacement_de_ressource(i, 3)
            IF (analysis->distance < min_dist)
                min_dist = analysis->distance
                best_move = analysis->direction
            ENDIF
            FREE(analysis)
        ENDIF
        
        // Envoi de la commande MOVE avec respect de la règle du dé partagé
        IF (i < 4)
            IF (best_move != 0 AND NOT deja_bouge)
                PRINT("MOVE ", INT, best_move, "\n")
                deja_bouge = TRUE
            ELSE
                PRINT("MOVE 0\n") 
            ENDIF
        ELSE
            PRINT("MOVE ", INT, best_move, "\n")
        ENDIF
    ENDFOR
    FLUSH()
END

/**
--------------------------------------------------------
Gère la validation des objectifs.
L'IA tente de revendiquer l'objectif le plus cher parmi ceux qu'elle peut actuellement payer.
--------------------------------------------------------
 */
FUNCTION phase_revendication()
    resources_ptr = calculate_current_resources()
    
    // Parcours inversé pour privilégier les objectifs à 200 points
    best_obj_to_claim = NULL
    i = 8
    WHILE(i >= 0)
        obj_ptr = liste_objectifs[i]
        IF (NOT objectifs_effectues[obj_ptr->id])
            IF (check_objective_achievable(obj_ptr, resources_ptr))
                best_obj_to_claim = obj_ptr
                i = -1 
            ENDIF
        ENDIF
        i = i - 1
    ENDWHILE

    IF (best_obj_to_claim == NULL)
        PRINT("PASS\n")
    ELSE
        PRINT("CLAIM ", INT, best_obj_to_claim->id, "\n")
    ENDIF

    FLUSH()
    FREE(resources_ptr)
END

/**
--------------------------------------------------------
Boucle principale du jeu.
Orchestre les 3 tours de jeu, et pour chaque tour, les 6 phases d'action composées de déplacements et de revendications.
--------------------------------------------------------
 */
FUNCTION main()
    initialisation()

    FOR(i;0;3)
        lecture_debut_tour()
        FOR(y;0;6)
            phase_deplacement_des()
            lecture_des_bouges()
            phase_revendication()
            lecture_objectif_fini()
        ENDFOR
    ENDFOR
    
    nettoyage()
END